name: Deploy SeeGap Application

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      terraform_action:
        description: 'Terraform action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: europe-west1
  GCP_ZONE: europe-west1-b
  TERRAFORM_VERSION: 1.6.0

jobs:
  # Infrastructure deployment with Terraform
  infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    if: github.event.inputs.terraform_action != '' || github.event_name == 'push'
    outputs:
      vm_ip: ${{ steps.terraform.outputs.vm_ip }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
        
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      
    - name: Create Terraform variables file
      working-directory: terraform
      run: |
        cat > terraform.tfvars << EOF
        gcp_project_id = "${{ secrets.GCP_PROJECT_ID }}"
        gcp_region = "${{ env.GCP_REGION }}"
        gcp_zone = "${{ env.GCP_ZONE }}"
        machine_type = "e2-medium"
        ssh_username = "HishamSait"
        ssh_public_key = "${{ secrets.SSH_PUBLIC_KEY }}"
        domain_name = "seegap.com"
        subdomain = "si"
        cloudflare_api_token = "${{ secrets.CLOUDFLARE_API_TOKEN }}"
        app_environment = "${{ github.event.inputs.environment || 'production' }}"
        db_password = "${{ secrets.DB_PASSWORD }}"
        db_root_password = "${{ secrets.DB_ROOT_PASSWORD }}"
        EOF
        
    - name: Terraform Init
      working-directory: terraform
      run: terraform init
      
    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -out=tfplan
      
    - name: Terraform Apply
      if: github.event.inputs.terraform_action != 'plan' && github.event.inputs.terraform_action != 'destroy'
      working-directory: terraform
      run: terraform apply -auto-approve tfplan
      
    - name: Terraform Destroy
      if: github.event.inputs.terraform_action == 'destroy'
      working-directory: terraform
      run: terraform destroy -auto-approve
      
    - name: Get Terraform Outputs
      if: github.event.inputs.terraform_action != 'destroy'
      id: terraform
      working-directory: terraform
      run: |
        echo "vm_ip=$(terraform output -raw static_ip_address)" >> $GITHUB_OUTPUT
        echo "domain_url=$(terraform output -raw domain_url)" >> $GITHUB_OUTPUT

  # Application deployment
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: infrastructure
    if: github.event.inputs.terraform_action != 'destroy' && github.event.inputs.terraform_action != 'plan'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
        
    - name: Add server to known hosts
      run: |
        ssh-keyscan -H ${{ needs.infrastructure.outputs.vm_ip || secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        
    - name: Wait for VM to be ready
      run: |
        echo "Waiting for VM to be ready..."
        for i in {1..30}; do
          if ssh -o ConnectTimeout=10 HishamSait@${{ needs.infrastructure.outputs.vm_ip || secrets.SERVER_HOST }} "echo 'VM is ready'"; then
            echo "VM is ready!"
            break
          fi
          echo "Attempt $i: VM not ready yet, waiting 30 seconds..."
          sleep 30
        done
        
    - name: Create application directory and setup Git
      run: |
        ssh HishamSait@${{ needs.infrastructure.outputs.vm_ip || secrets.SERVER_HOST }} << 'EOF'
          # Create app directory if it doesn't exist
          mkdir -p ~/seegap-app
          cd ~/seegap-app
          
          # Initialize git repository if not exists
          if [ ! -d .git ]; then
            git init
            git remote add origin https://github.com/${{ github.repository }}.git
            git branch -M main
          fi
          
          # Ensure we're on the main branch
          git checkout main 2>/dev/null || git checkout -b main
        EOF
        
    - name: Deploy application code
      run: |
        ssh HishamSait@${{ needs.infrastructure.outputs.vm_ip || secrets.SERVER_HOST }} << 'EOF'
          cd ~/seegap-app
          
          # Pull latest code
          git fetch origin main
          git reset --hard origin/main
          
          # Make deploy script executable
          chmod +x deploy.sh
          
          # Run deployment
          ./deploy.sh
        EOF
        
    - name: Configure environment
      run: |
        ssh HishamSait@${{ needs.infrastructure.outputs.vm_ip || secrets.SERVER_HOST }} << 'EOF'
          cd ~/seegap-app
          
          # Create .env file from template if it doesn't exist
          if [ ! -f .env ]; then
            cp .env.example .env
          fi
          
          # Update environment variables
          sed -i "s|SITE_URL=.*|SITE_URL=https://si.seegap.com|g" .env
          sed -i "s|APP_ENV=.*|APP_ENV=production|g" .env
          sed -i "s|APP_DEBUG=.*|APP_DEBUG=false|g" .env
        EOF
        
    - name: Start Docker services
      run: |
        ssh HishamSait@${{ needs.infrastructure.outputs.vm_ip || secrets.SERVER_HOST }} << 'EOF'
          cd ~/seegap-app
          
          # Stop existing containers
          docker-compose down || true
          
          # Pull latest images
          docker-compose pull
          
          # Start services
          docker-compose up -d
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 60
          
          # Check service status
          docker-compose ps
        EOF

  # Health check and verification
  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [infrastructure, deploy]
    if: github.event.inputs.terraform_action != 'destroy' && github.event.inputs.terraform_action != 'plan'
    
    steps:
    - name: Wait for application to be ready
      run: |
        echo "Waiting for application to be accessible..."
        for i in {1..20}; do
          if curl -f -s https://si.seegap.com > /dev/null; then
            echo "‚úÖ Application is accessible!"
            break
          fi
          echo "Attempt $i: Application not ready yet, waiting 30 seconds..."
          sleep 30
        done
        
    - name: Run health checks
      run: |
        echo "üîç Running health checks..."
        
        # Check main page
        if curl -f -s https://si.seegap.com > /dev/null; then
          echo "‚úÖ Main page is accessible"
        else
          echo "‚ùå Main page is not accessible"
          exit 1
        fi
        
        # Check SSL certificate
        if curl -f -s -I https://si.seegap.com | grep -q "HTTP/2 200\|HTTP/1.1 200"; then
          echo "‚úÖ SSL certificate is working"
        else
          echo "‚ùå SSL certificate issue"
          exit 1
        fi
        
        echo "üéâ All health checks passed!"
        
    - name: Deployment Summary
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ github.event.inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Domain**: https://si.seegap.com" >> $GITHUB_STEP_SUMMARY
        echo "- **VM IP**: ${{ needs.infrastructure.outputs.vm_ip || 'existing' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # Rollback job (manual trigger only)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: [deploy]
    
    steps:
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
        
    - name: Rollback to previous version
      run: |
        ssh HishamSait@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ~/seegap-app
          
          # Get previous commit
          PREVIOUS_COMMIT=$(git log --oneline -n 2 | tail -1 | cut -d' ' -f1)
          
          echo "Rolling back to commit: $PREVIOUS_COMMIT"
          git reset --hard $PREVIOUS_COMMIT
          
          # Restart services
          docker-compose down
          docker-compose up -d
        EOF
        
    - name: Verify rollback
      run: |
        sleep 60
        if curl -f https://si.seegap.com > /dev/null; then
          echo "‚úÖ Rollback successful"
        else
          echo "‚ùå Rollback failed"
          exit 1
        fi
